package biz.storebiz.biz.service.db.implementation;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.slim3.datastore.Datastore;

import biz.storebiz.app.entity.view.AddressViewModel;
import biz.storebiz.app.entity.view.WebViewModel;
import biz.storebiz.biz.service.db.IAddressDBService;
import biz.storebiz.db.entity.common.Address;
import biz.storebiz.db.entity.common.AddressMeta;
import biz.storebiz.utils.AppEntityConverter;

import com.google.appengine.api.datastore.Key;

public class AddressDBServiceImpl implements IAddressDBService, Serializable {

	@Override
	public synchronized AddressViewModel put(AddressViewModel viewModel) {
		AddressViewModel addressViewModel = (AddressViewModel)viewModel;
		Address address = AppEntityConverter
				.convertViewModelToDBEntity(addressViewModel);
		if (address.getAddressKey() == null) {
			// The address has to be added in the database.
			// In case, the address has to be updated then the key should not
			// have been blank.
			// Its also Ok for the Key to be generated by some other means,
			// as long as it does not violate any GAE principals the application
			// does not care.
			Key addressKey = Datastore.allocateId(Address.class);
			address.setAddressKey(addressKey);
			addressViewModel.setGaeAddressKey(addressKey);
		}

		Datastore.put(address);

		return AppEntityConverter.convertDBEntityToViewModel(address);
	}

	@Override
	public List<AddressViewModel> getAllAddresses(Key gaeOwnerKey) {

		AddressMeta addrMeta = AddressMeta.get();
		Iterator<Address> addresses = Datastore.query(addrMeta)
				.filter(addrMeta.addressownerKey.equal(gaeOwnerKey))
				.asIterator();
		List<AddressViewModel> addrViewModel = new ArrayList<AddressViewModel>();
		while (addresses.hasNext()) {
			addrViewModel.add(AppEntityConverter
					.convertDBEntityToViewModel(addresses.next()));
		}
		return addrViewModel;
	}

	
	@Override
	public List<AddressViewModel> getAll() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<AddressViewModel> getById(String id) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public AddressViewModel getByGaeKey(Key gaeKey) {
		return AppEntityConverter.convertDBEntityToViewModel(Datastore.get(
				Address.class, gaeKey));
	}

	@Override
	public String generateUniqueId(AddressViewModel viewModel) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<AddressViewModel> findByText(String findText) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public synchronized List<AddressViewModel> put(List<AddressViewModel> addresses) {
		List<Address> addrList = new ArrayList<Address>();
		for (WebViewModel webVm : addresses) {
			AddressViewModel addrVm = (AddressViewModel) webVm;
			Address addr = AppEntityConverter
					.convertViewModelToDBEntity(addrVm);
			if (addr.getAddressKey() == null) {
				// The address has to be added in the database. In case, they
				// already exist, then updated them.
				// Its also Ok for the Key to be generated by some other means,
				// as long as it does not violate any GAE principals the
				// application
				// does not care.
				Key addressKey = Datastore.allocateId(Address.class);
				addr.setAddressKey(addressKey);
				
			}
			addrList.add(addr);
		}
		Datastore.put(addrList);

		// Recreate list of new View Objects containing GAE DB related
		// information, which were absent until data is written in the database.
		List<AddressViewModel> addressVMList2 = new ArrayList<AddressViewModel>();
		for (Address addr : addrList) {
			addressVMList2.add(AppEntityConverter
					.convertDBEntityToViewModel(addr));
		}

		return addressVMList2;
	}

}
